{const a=(a=new Map,b={get:(b)=>a.get(b),set(c,d){return(a.has(c)?a:a.set(c,new Set)).get(c).add(d),b},del(c,d){return a.has(c)&&1>a.get(c).delete(d).size&&a.delete(c),b},has(b,c){const d=a.has(b);return c!==void 0&&d?a.get(b).has(c):d},each(c,d){return b.has(c)&&a.get(c).forEach(d),b}})=>b;var SuperModel=(b=new Map)=>{const c=a(),d=(a,b)=>(b.off=()=>c.del(a,b),b.once=()=>(b.off(),g(a,b)),b.on=()=>(b.off(),f(a,b)),b),e=(a,b=!0)=>new Proxy(a,{get(c,d){return b&&Reflect.has(a,d)?Reflect.get(a,d):a.bind(null,d)}}),f=e((a,b)=>(c.set(a,b),d(a,b))),g=e((a,b)=>{const e=(...d)=>(c.del(a,e),b(...d));return c.set(a,e),d(a,e)}),h=e((a,...b)=>{c.each(a,(a)=>{a(...b)})},!1),i=e((a,...b)=>{setTimeout(()=>{c.each(a,(a)=>{setTimeout(()=>{a(...b)},0)})},0)},!1),j=(a)=>{b.delete(a),h('delete',a),h('delete:'+a)},l=(a,c)=>{if(a&&a.constructor===Object){for(let b in a)l(b,a[b]);return l}const d=b.get(a);return void 0!==c&&c!==d?(b.set(a,c),h('set',a,c),h('set:'+a,c),l):(h('get',a),h('get:'+a),d)},k=new Map,m=(a,c,d=c)=>(k.has(a)||k.set(a,new Map),k.get(a).set(d,f('set:'+d,(b)=>{a[c]=b})),b.has(c)&&(a[c]=b.get(c)),a);m.stop=(a,b)=>{if(k.has(a)){const c=k.get(a);b?c.has(b)&&(c.get(b).off(),c.delete(b)):c.forEach((a)=>a.off()).clear(),c.size||k.delete(a)}return a};const n=new Proxy((a,c)=>{b.has(a)?c(b.get(a)):g('set:'+a,c)},{get:(a,c)=>new Promise((a)=>{b.has(c)?a(b.get(c)):g('set:'+c,a)}),set(a,b,c){c.then(l.bind(null,b))}});return new Proxy(Object.assign(l,{emit:h,emitAsync:i,listen:(a,b,c)=>(a?g:f)(b,c),on:f,once:g,has:(a)=>b.has(a),store:b,sync:m,syncs:k,del:j}),{get(a,b){return Reflect.has(a,b)?Reflect.get(a,b):'async'===b?n:l(b)},set(a,b,c){return c&&c.constructor===Promise?n[b]=c:l(b,c)},delete:(a,b)=>j(b)})};SuperModel.listMap=a}